!
! Note that at the time this module was created, gfortran 5.1 did not correctly
! retain lengths of strings when treated as unlimited polymorphic entities.
! Hence, character in such maps must be quoted inside a String object.
!
module Test_Config_mod
#ifdef __GFORTRAN__
   use FTL_String_mod
#endif
   use pfunit_mod
   use ASTG_Logger_mod
   use ASTG_LoggerManager_mod
   use ASTG_SeverityLevels_mod

   use ASTG_Config_mod

   implicit none

#ifdef __GFORTRAN__   
#define P(k,v) p(k,String(v))
#endif
   
contains


   @test
   subroutine test_check_schema_specified()
      type (Config) :: dict

      call dictConfig(dict) ! Empty config
      @assertExceptionRaised("ASTG::Config::dictConfig() - must specify a schema_version for Config.")

   end subroutine test_check_schema_specified


   @test
   subroutine test_check_schema_version_unsupported()
      type (Config) :: dict

      call dict%insert('schema_version', 2)
      call dictConfig(dict)
      @assertExceptionRaised('ASTG::Config::dictConfig() - unsupported schema_version. Allowed values are [1].')

   end subroutine test_check_schema_version_unsupported


   @test
   subroutine test_check_schema_version_valid()
      type (Config) :: dict

      call dict%insert('schema_version', 1) ! currently only valid option
      call dictConfig(dict)

   end subroutine test_check_schema_version_valid


   @test
   subroutine test_build_formatter_noargs()
      use ASTG_Formatter_mod
      use ASTG_LogRecord_mod
      type (Config) :: cfg
      type (Formatter) :: fmtr
      type (LogRecord) :: record
      character(len=:), allocatable :: logMessage

      fmtr = build_formatter(cfg)

      call initLogRecord(record, 'A', DEBUG, 'hello')
      logMessage = fmtr%format(record)
      @assertEqual('hello', logMessage)

   end subroutine test_build_formatter_noargs

   
   @test
   subroutine test_build_formatter_withFmt()
      use ASTG_Formatter_mod
      use ASTG_LogRecord_mod
      type (Config) :: cfg
      type (Formatter) :: fmtr
      type (LogRecord) :: record
      character(len=:), allocatable :: logMessage

      cfg = Config([P('fmt','---')])
      fmtr = build_formatter(cfg)

      call initLogRecord(record, 'A', DEBUG, 'hello')
      logMessage = fmtr%format(record)
      @assertEqual('---', logMessage)

   end subroutine test_build_formatter_withFmt

   @test
   subroutine test_build_formatter_withDateFmt()
      use ASTG_Formatter_mod
      use ASTG_LogRecord_mod
      type (Config) :: cfg
      type (Formatter) :: fmtr
      type (LogRecord) :: record
      character(len=:), allocatable :: logMessage

      cfg = Config([P('fmt','%(asctime)a %(message)a'), P('datefmt','date')])
      fmtr = build_formatter(cfg)

      call initLogRecord(record, 'A', DEBUG, 'hello')
      logMessage = fmtr%format(record)
      @assertEqual('date hello', logMessage)

   end subroutine test_build_formatter_withDateFmt

   @test
   subroutine test_build_formatters()
      use ASTG_StringFormatterMap_mod
      type (Config) :: formattersDict
      type (FormatterMap) :: formatters

      formattersDict = &
           & Config([ &
           &       p('A', Config([P('fmt','---')]) ), &
           &       p('B', Config([P('fmt','---'), P('datefmt', 'hello')])) &
           &     ])

      formatters = build_formatters(formattersDict)
      @assertEqual(2, formatters%size())

   end subroutine test_build_formatters

   @test
   subroutine test_build_filter()
      use ASTG_Filter_mod
      type (Config) :: cfg
      type (Filter) :: f
      character(len=:), allocatable :: logMessage

      cfg = Config([P('name', 'A')])
      f = build_filter(cfg)

      @assertEqual('A', f%getName())

   end subroutine test_build_filter

   @test
   subroutine test_build_filters()
      use ASTG_StringFilterMap_mod
      type (Config) :: filtersDict
      type (FilterMap) :: filters

      filtersDict = &
           & Config([ &
           &       p('A', Config([P('name', 'A')])), &
           &       p('B', Config([P('name', 'B')])) &
           &     ])

      filters = build_filters(filtersDict)
      @assertEqual(2, filters%size())

   end subroutine test_build_filters


   @test
   subroutine test_build_streamhandler()
      use ASTG_StreamHandler_mod
      use ASTG_LogRecord_mod
      type (Config) :: handler_cfg
      type (StreamHandler) :: h
      integer :: unit
      character(len=10) :: unitStr
      type (LogRecord) :: record

      open(newunit=unit, file='test_build_streamhandler.txt', status='unknown', &
           & form='formatted')
     
      write(unitStr,'(i0)') unit
      handler_cfg = Config([ &
           & P('class', 'StreamHandler'), &
           & P('unit', unitStr), &
           & P('level', 'INFO') &
           & ])

      ! Note that, level, filters, and format are added at a higher level.
      h = build_streamhandler(handler_cfg)
      call initLogRecord(record, 'A', DEBUG, 'hello')
      call h%handle(record)

      rewind(unit)
      block
        character(len=80) :: str
        read(unit,'(a)') str
        @assertEqual('DEBUG: A: hello', str)
      end block
      close(unit, status='delete')
      

   end subroutine test_build_streamhandler

   @test
   subroutine test_build_handler()
      use ASTG_StringFormatterMap_mod
      use ASTG_StringFilterMap_mod
      use ASTG_StreamHandler_mod
      use ASTG_Filter_mod
      use ASTG_Formatter_mod
      use ASTG_AbstractHandler_mod
      use ASTG_LogRecord_mod
      type (Config) :: handler_cfg
      class (AbstractHandler), allocatable :: h

      type (FilterMap) :: filters
      type (FormatterMap) :: formatters
      integer :: unit
      character(len=10) :: unitStr
      type (LogRecord) :: record


      call filters%insert('filterA',Filter('A'))
      call filters%insert('filterB',Filter('B'))

      call formatters%insert('formatterA', Formatter('%(message)a'))
      call formatters%insert('formatterB', Formatter('%(levelName)a~: %(message)a'))

      open(newunit=unit, file='test_build_handler.txt', status='unknown', &
           & form='formatted')
      write(unitStr,'(i0)') unit
      handler_cfg = Config([ &
           & P('class', 'StreamHandler'), &
           & P('unit', unitStr), &
           & P('formatter', 'formatterB'), &
           & P('filters', '[filterA]'), &
           & P('level', 'INFO') &
           & ])


      allocate(h, source=build_handler(handler_cfg, formatters, filters))
      @assertEqual(INFO, h%getLevel(),'incorrect level')

      block
        character(len=80) :: str
        type (LogRecord) :: record
        
!!$        call initLogRecord(record, 'B', INFO, 'hello')
!!$        call h%handle(record) ! skip - filter 'A'
!!$        
!!$        call initLogRecord(record, 'A', DEBUG, 'goodbye')
!!$        call h%handle(record) ! skip - level is INFO
!!$        
        call initLogRecord(record, 'A', INFO, 'ciao')
        call h%handle(record) ! keep
        
        rewind(unit)

        read(unit,'(a)') str
        @assertEqual('INFO: ciao', str)
      end block
      close(unit, status='delete')
      

   end subroutine test_build_handler

   @test
   subroutine test_build_handlers()
      use ASTG_StringHandlerMap_mod
      use ASTG_StringFormatterMap_mod
      use ASTG_StringFilterMap_mod
      use ASTG_Filter_mod
      use ASTG_StreamHandler_mod
      use ASTG_Formatter_mod
      type (Config) :: handlersDict
      type (HandlerMap) :: handlers

      type (Config) :: h1_cfg, h2_cfg

      type (FilterMap) :: filters
      type (FormatterMap) :: formatters

      call filters%insert('filterA',Filter('A'))
      call filters%insert('filterB',Filter('B'))

      call formatters%insert('formatterA', Formatter('%(message)'))
      call formatters%insert('formatterB', Formatter('%(levelname)'))


      h1_cfg = Config([ &
           & P('class', 'StreamHandler'), &
           & P('unit', 'OUTPUT_UNIT'), &
           & P('formatter', 'formatterA'), &
           & P('filters', '[filterA]'), &
           & P('level', 'INFO') &
           & ])

      h2_cfg = Config([ &
           & P('class', 'StreamHandler'), &
           & P('unit', 'OUTPUT_UNIT'), &
           & P('formatter', 'formatterB'), &
           & P('filters', '[filterA,filterB]'), &
           & P('level', 'CRITICAL') &
           & ])

      handlersDict = &
           & Config([ &
           &       p('A', h1_cfg), &
           &       p('B', h2_cfg) &
           &     ])

!!$      handlers = build_handlers(handlersDict, formatters, filters)
      call build_handlers(handlers, handlersDict, formatters, filters)
      @assertEqual(2, handlers%size())

   end subroutine test_build_handlers

@test
   subroutine test_build_logger_trivial()
      use ASTG_StringFilterMap_mod
      use ASTG_StringHandlerMap_mod

      type (Config) :: cfg
      type (FilterMap) :: filters
      type (HandlerMap) :: handlers

      ! cfg is empty by default
      call build_logger('A', cfg, filters, handlers)

   end subroutine test_build_logger_trivial

   @test
   subroutine test_build_logger()
      use ASTG_StringFilterMap_mod
      use ASTG_StringHandlerMap_mod

      use ASTG_Filter_mod
      use ASTG_AbstractHandler_mod
      use ASTG_FileHandler_mod

      type (Config) :: cfg
      type (FilterMap) :: filters
      type (HandlerMap) :: handlers

      call handlers%insert('handlerA', FileHandler('A', delay=.true.))
      call handlers%insert('handlerB', FileHandler('B', delay=.true.))

      call filters%insert('filterA', Filter('A'))
      call filters%insert('filterB', Filter('B'))

      call build_logger('A', cfg, filters, handlers)

   end subroutine test_build_logger

@test
   subroutine test_build_logger_serial_in_mpi_context()
      use mpi
      use ASTG_StringFilterMap_mod
      use ASTG_StringHandlerMap_mod
      use MockHandler_mod
      use MockMpi_mod
      use ASTG_SeverityLevels_mod

      type (Config) :: cfg
      type (FilterMap) :: filters
      type (HandlerMap) :: handlers
      type (MockBuffer) :: buffer
      type (Logger), pointer :: lgr
      type (MockHandler) :: h

      call set_mpi_rank(1)
      call set_mpi_size(2)

      ! loggers:
      !     serial:
      !         handlers: [A, B]

      ! When not root, serial logger should get no handlers

      h = MockHandler(buffer, level=INFO)
      call handlers%insert('handlerA', h)

      cfg = Config([P('handlers','[handlerA]')])
      call build_logger('serial', cfg, filters, handlers)

      lgr => logging%getLogger('serial')
      buffer%buffer = ''
      call lgr%info('message')
      call assertEqual('',buffer%buffer)
      

   end subroutine test_build_logger_serial_in_mpi_context


@test
   subroutine test_build_logger_serial_comm()
      use mpi
      use ASTG_StringFilterMap_mod
      use ASTG_StringHandlerMap_mod
      use MockHandler_mod
      use MockMpi_mod
      use ASTG_SeverityLevels_mod

      type (Config) :: cfg
      type (FilterMap) :: filters
      type (HandlerMap) :: handlers
      type (MockBuffer) :: buffer
      type (Logger), pointer :: lgr
      type (MockHandler) :: h
      type (Config) :: extra

      integer :: comm ! fake comm

      call set_mpi_rank(0)
      call set_mpi_size(2)

      ! loggers:
      !     serial:
      !         handlers: [A, B]

      ! When not root, serial logger should get no handlers

      h = MockHandler(buffer, level=INFO)
      call handlers%insert('handlerA', h)

      cfg = Config([P('handlers','[handlerA]')])
      extra = Config([p('comm', comm)])
      call build_logger('serial', cfg, filters, handlers, extra=extra)

      lgr => logging%getLogger('serial')
      buffer%buffer = ''
      call lgr%info('message')
      call assertEqual('message',buffer%buffer)
      
   end subroutine test_build_logger_serial_comm

   
   @test
   subroutine test_basic_loggers_invalid_cfg()
      type (Config) :: cfg
      type (Config) :: loggers

      class (Logger), pointer :: lgr
      character(len=:), allocatable :: expectedMessage

      cfg = Config([ &
           &      p('schema_version', 1), &
           &      p('loggers', 1) &
           &     ])

      call dictConfig(cfg)

      lgr => logging%getLogger('A')
      expectedMessage = "FTL::Config::toConfigPtr() - type of 'loggers' is not a Config."
      @assertExceptionRaised(expectedMessage)

   end subroutine test_basic_loggers_invalid_cfg

   @test
   subroutine test_basic_loggers()
      type (Config) :: cfg
      type (Config) :: loggers

      class (Logger), pointer :: lgr

      cfg = Config([ &
           &      p('schema_version', 1), &
           &      p('loggers', Config([p('A', Config([P('level','DEBUG')]))])) &
           &     ])

      call dictConfig(cfg)
      lgr => logging%getLogger('A')

      @assertEqual(DEBUG, lgr%getLevel())

   end subroutine test_basic_loggers


end module Test_Config_mod
