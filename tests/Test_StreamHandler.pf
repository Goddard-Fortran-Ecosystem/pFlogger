module Test_StreamHandler_mod
   use pFUnit_mod
   use ASTG_SeverityLevels_mod
   use ASTG_StreamHandler_mod
   use ASTG_LogRecord_mod
   use ASTG_Formatter_mod
   use MockDateFormat_mod
   use ASTG_AbstractFilter_mod
   implicit none

@TestCase
   type, extends(TestCase) :: Test_StreamHandler
      type (Formatter) :: f
      integer :: unit
   contains
      procedure :: setUp   
      procedure :: tearDown 
   end type Test_StreamHandler


   type, extends(AbstractFilter) :: LocalFilter
      logical :: filterOn = .false.
   contains
      procedure :: doFilter
      procedure :: equal
   end type LocalFilter

contains

   
   subroutine setUp(this)
      class (Test_StreamHandler), intent(inout) :: this

      open(newunit=this%unit, file='testStreamHandler.txt', form='formatted', &
           status='new')
      mockdf%f = Formatter()
      mockdf%Y = 2015
      mockdf%M = 1
      mockdf%D = 2
      mockdf%HH = 3
      mockdf%MM = 4
      mockdf%SS = 5
      mockdf%MS = 123

   end subroutine setUp

   
   subroutine tearDown(this)
      class (Test_StreamHandler), intent(inout) :: this

      close(this%unit, status='delete')

   end subroutine tearDown

   
@Test
   subroutine test_handleBasic(this)
      class (Test_StreamHandler), intent(inout) :: this
      type (StreamHandler) :: handler
      character(len=32) :: foundMessage
      type (LogRecord) :: rec


      handler = StreamHandler(unit=this%unit)
      call handler%setLevel(INFO)
      call initLogRecord(rec, name='SHname', messageformat='hello', level=INFO)
      call handler%handle(rec)

      rewind(this%unit)
      read(this%unit,'(a)') foundMessage
      
      @assertEqual('INFO: SHname: hello', foundMessage)

   end subroutine test_handleBasic

@Test
   subroutine test_emitBasicWithFormat(this)
      use ASTG_UnlimitedVector_mod, only: UnlimitedVector => Vector
      use ASTG_Formatter_mod
      class (Test_StreamHandler), intent(inout) :: this
      type (StreamHandler) :: handler
      character(len=32) :: foundMessage

      type (LogRecord) :: record
      type(Formatter) :: fmt
      type (UnlimitedVector) :: args
      
      args = UnlimitedVector()
      call args%push_back(1)

      ! Create a logging format
      fmt = Formatter('%(levelName)a~: %(name)a~: %(message)a')

      handler = StreamHandler(unit=this%unit)
      call handler%setFormatter(fmt)
      call initLogRecord(record, 'A', INFO, 'Goodbye %i1.1', args=args)
      call handler%handle(record)
      
      rewind(this%unit)
      read(this%unit,'(a)') foundMessage
      @assertEqual('INFO: A: '//record%getMessage(), foundMessage)
      
   end subroutine test_emitBasicWithFormat

   
@Test
   subroutine test_emitBasicWithFormatAndDate(this)
      use ASTG_UnlimitedVector_mod, only: UnlimitedVector => Vector
      use ASTG_Formatter_mod
      use ASTG_CIStringUnlimitedMap_mod, only: CIStringUnlimitedMap => Map
      class (Test_StreamHandler), intent(inout) :: this
      type (StreamHandler) :: handler
      character(len=32) :: foundMessage

      type (LogRecord) :: record
      type(Formatter) :: fmt
      type (UnlimitedVector) :: args
      type (CIStringUnlimitedMap) :: extra
      character(len=:), allocatable :: levelName
      
      args = UnlimitedVector()
      call args%push_back(1)

      ! Create a LogRecord
      record%name = 'someRec'
      record%level = INFO
      record%messageformat = 'datefmt'

      call record%extra%insert('name', 'someRec')
      call record%extra%insert('level', INFO)
      levelName = levelToString(INFO)
      call record%extra%insert('levelName', levelName)

      call mockdf%fillDateAndTime(record)
      mockdf%f = Formatter(&
           fmt='%(asctime)a %(levelName)a~: %(name)a~: %(message)a', &
           datefmt='%(HH)i2.2~-%(MM)i2.2~-%(SS)i2.2')

      handler = StreamHandler(unit=this%unit)
      call handler%setFormatter(mockdf%f)
      call handler%handle(record)
      
      rewind(this%unit)
      read(this%unit,'(a)') foundMessage
      @assertEqual('03-04-05 INFO: someRec: '//record%getMessage(), foundMessage)
      
   end subroutine test_emitBasicWithFormatAndDate

   
! The python implementation only checks the handler level at
! within Logger.   Seems that it is better to check in Handler,
! with possibly a very small bit of overhead.  SHould only matter
! if there are many handlers and only a few actually emit.
   
@Test
   subroutine test_handleBelowThreshold(this)
      use iso_fortran_env, only: IOSTAT_END
      class (Test_StreamHandler), intent(inout) :: this

      type (StreamHandler) :: handler
      character(len=32) :: foundMessage
      integer :: iostatus
      type (LogRecord) :: record
      
      handler = StreamHandler(unit=this%unit)
      call handler%setLevel(INFO)
      record = LogRecord('name', DEBUG, 'hello')
      call handler%handle(record)

      rewind(this%unit)
      read(this%unit,'(a)', IOSTAT=iostatus) foundMessage
      
      @assertEqual(IOSTAT_END, iostatus)

   end subroutine test_handleBelowThreshold

   
@Test
   subroutine test_handleAboveThreshold(this)
      class (Test_StreamHandler), intent(inout) :: this

      type (StreamHandler) :: handler
      character(len=32) :: foundMessage
      type (LogRecord) :: record

      handler = StreamHandler(unit=this%unit)
      call handler%setLevel(INFO)
      record = LogRecord('name', CRITICAL, 'hello')
      call handler%handle(record)

      rewind(this%unit)
      read(this%unit,'(a)') foundMessage
      
      @assertEqual('CRITICAL: name: hello', foundMessage)

   end subroutine test_handleAboveThreshold
   

   @test
   subroutine test_equal(this)
      class (Test_StreamHandler), intent(inout) :: this

      type (StreamHandler) :: a
      type (StreamHandler) :: b

      a = StreamHandler(unit=this%unit)
      b = StreamHandler(unit=this%unit)

      @assertTrue(a == b)
      @assertFalse(a /= b)

   end subroutine test_equal


   @test
   subroutine test_equalDifferentLevel(this)
      class (Test_StreamHandler), intent(inout) :: this


      type (StreamHandler) :: a
      type (StreamHandler) :: b

      a = StreamHandler(unit=this%unit)
      call a%setLevel(INFO)
      b = StreamHandler(unit=this%unit)
      call b%setLevel(DEBUG)

      @assertFalse(a == b)
      @assertTrue(a /= b)

   end subroutine test_equalDifferentLevel


   @test
   subroutine test_equalDifferentUnit(this)
      class (Test_StreamHandler), intent(inout) :: this


      type (StreamHandler) :: a
      type (StreamHandler) :: b

      a = StreamHandler()
      b = StreamHandler(unit=this%unit)

      @assertFalse(a == b)
      @assertTrue(a /= b)

   end subroutine test_equalDifferentUnit

   ! This next test is to ensure that filtering beyond level checking
   ! is working in the handler hierarchy.
   @test
   subroutine test_doFilter_off(this)
      use iso_fortran_env, only: IOSTAT_END
      class (Test_StreamHandler), intent(inout) :: this

      integer :: iostatus
      type (StreamHandler) :: handler
      character(len=32) :: foundMessage
      type (LocalFilter) :: f
      type (LogRecord) :: record
      
      handler = StreamHandler(unit=this%unit)
      call handler%setLevel(INFO)
      f%filterOn = .false.
      call handler%addFilter(f)
      record = LogRecord('name', INFO, 'hello')
      call handler%handle(record)

      rewind(this%unit)
      read(this%unit,'(a)', IOSTAT=iostatus) foundMessage
      @assertEqual(IOSTAT_END, iostatus)

   end subroutine test_doFilter_off


   logical function doFilter(this, record)
      class (LocalFilter), intent(in) :: this
      type (LogRecord), intent(inout) :: record

      doFilter = this%filterOn
   end function doFilter

   logical function equal(a, b)
      use iso_fortran_env, only: IOSTAT_END
      class (LocalFilter), intent(in) :: a
      class (AbstractFilter), intent(in) :: b

      select type (b)
      class is (LocalFilter)
         equal = (a%filterOn .eqv. b%filterOn)
      class default
         equal = .false.
      end select
   end function equal

end module Test_StreamHandler_mod
