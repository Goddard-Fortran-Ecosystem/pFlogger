module Test_FormatParser_mod
   use pFUnit_mod
   use FTL_String_mod
   use FTL_StringVec_mod
   use ASTG_FormatParser_mod
   
   implicit none

contains

   ! Valid format specifications MUST beging with a FORMAT_DELIMITER '%'
   @test
   subroutine test_isFormat()
      type(FormatParser) :: parser
      logical :: isFmt
      
      @assertTrue(parser%isFormat('%a'))
      ! Empty string throws an exception
      isFmt=parser%isFormat('')
      @assertExceptionRaised('Illegal - empty string in FormatParser.')
      ! Else...
      @assertFalse(parser%isFormat(' '))
      @assertFalse(parser%isFormat('A'))
      @assertFalse(parser%isFormat('\%'))
      @assertFalse(parser%isFormat('\%a'))
      
   end subroutine test_isFormat

   ! A keyword string must be separated by KEYWORD_SEPARATOR.
   ! Example %(message::a), else throw exception
   @test
   subroutine test_illegalKeywordSep()
      type(FormatParser) :: parser
      logical :: isThere

      isThere = parser%formatContainsKey('%(a:i1)')
      @assertExceptionRaised('Illegal keyword separator - must use ::')
      isThere = parser%formatContainsKey('%(a : )')
      @assertExceptionRaised('Illegal keyword separator - must use ::')

   end subroutine test_illegalKeywordSep

   ! Tests with valid KEYWORD_SEPARATOR
   @test
   subroutine test_formatContainsKey()
      type(FormatParser) :: parser
      
      @assertTrue(parser%formatContainsKey('%(a::i1)'))
      ! Since no KEYWORD_SEPARATOR, returns FALSE
      @assertFalse(parser%formatContainsKey('%(i1)'))
      
   end subroutine test_formatContainsKey

   ! Tests to check for the contents of the format before the KEYWORD_SEPARATOR
   @test
   subroutine test_getFormatKey()
      type(FormatParser) :: parser
      
      @assertEqual('a', parser%getFormatKey('%(a::i1)'))
      @assertEqual('', parser%getFormatKey('%i1'))
      @assertEqual('', parser%getFormatKey('%(a)'))

   end subroutine test_getFormatKey


   ! Format strings have two types of tokens: regular text and format specifiers
   ! (those that contain a FORMAT_DELIMITER, %).
   @test
   subroutine test_startOfNextTokenRegularText()
      type(FormatParser) :: parser

      ! Regular text tokens
      ! Note startOfNextToken returns size of token + 1
      @assertEqual(2, parser%startOfNextToken('a'))
      @assertEqual(6, parser%startOfNextToken('hello'))
      ! 'Escaped' regular text
      @assertEqual(3, parser%startOfNextToken('\a'))
      ! If regular text then space counts as a token
      @assertEqual(3, parser%startOfNextToken('a '))
      @assertEqual(4, parser%startOfNextToken('a b'))
      @assertEqual(5, parser%startOfNextToken('a b '))
      @assertEqual(5, parser%startOfNextToken(' a b'))

   end subroutine test_startOfNextTokenRegularText

   @test
   subroutine test_startOfNextTokenFormatDelimiter()
      type(FormatParser) :: parser

      ! FORMAT_DELIMITER tokens
      @assertEqual(2, parser%startOfNextToken('%'))
      ! Two tokens: 'a' and anything after % 
      @assertEqual(2, parser%startOfNextToken('a%2.1'))
      ! Space before % is NOT a token
      @assertEqual(2, parser%startOfNextToken(' %2.1'))
      ! Space after token implies end of token
      @assertEqual(3, parser%startOfNextToken('%a a'))
      @assertEqual(6, parser%startOfNextToken('%i2.1 hello'))
      ! Text enclosed in PARENS counts as 1 token
      @assertEqual(8, parser%startOfNextToken('%(i2.1) hello'))
      ! 'Escaped' % is counted as regulat text
      @assertEqual(10, parser%startOfNextToken('\% other '))

   end subroutine test_startOfNextTokenFormatDelimiter


   @test
   subroutine test_startOfNextToken_nestedParens()
      type(FormatParser) :: parser
      
      @assertEqual(13, parser%startOfNextToken('%(2(i1.1,x))'))

   end subroutine test_startOfNextToken_nestedParens


   ! Test for invalid format descriptors.
   @test
   subroutine test_getPayload_illegalString()
      type(FormatParser) :: parser
      character(len=:), allocatable :: str

      ! In all these cases, getPayLoad throws an exception and we catch it here.
      str = parser%getPayload('')
      @assertExceptionRaised("Illegal - empty string in FormatParser.")

      str = parser%getPayload('%')
      @assertExceptionRaised("Empty format descriptor in FormatParser.")

      str = parser%getPayload('%()')
      @assertExceptionRaised("Empty format descriptor in FormatParser.")

      str = parser%getPayload('%(::)')
      @assertExceptionRaised("Empty format descriptor in FormatParser.")

   end subroutine test_getPayload_illegalString


   ! Test for valid format descriptors. In this case getPayload returns
   ! a string wrapped in PARENS for use if Fortran format.
   @test
   subroutine test_getPayload()
      type(FormatParser) :: parser

      ! Regular text
      @assertEqual('a', parser%getPayload('a'))
      @assertEqual('ab', parser%getPayload('ab'))
      @assertEqual('a b', parser%getPayload('a b'))
      ! 'Escaped' text
      @assertEqual('\%a', parser%getPayload('\%a'))

      ! Text delimited by FORMAT_DELIMITER 
      @assertEqual('(a)', parser%getPayload('%a'))
      @assertEqual('(i2.1)', parser%getPayload('%i2.1'))
      @assertEqual('(i2.1)', parser%getPayload('%(i2.1)'))

      @assertEqual('(i1.1)', parser%getPayload('%(hi::i1.1)'))

   end subroutine test_getPayload

   ! Test that getTokens returns the correct 'number' of tokens, so test
   ! for the correctness of the size of a vector of tokens.
   ! Note that getTokens internally calls startOfNextToken.
   @test
   subroutine test_countTokens()
      type(FormatParser) :: parser
      type(StringVec) :: tokens

      tokens = parser%getTokens('')
      @assertEqual(0, tokens%size())
      
      tokens = parser%getTokens('a')
      @assertEqual(1, tokens%size())

      tokens = parser%getTokens('a ')
      @assertEqual(1, tokens%size())      

      tokens = parser%getTokens('a b')
      @assertEqual(1, tokens%size())      
      
      tokens = parser%getTokens(' a')
      @assertEqual(1, tokens%size())      
      
      tokens = parser%getTokens('%a')
      @assertEqual(1, tokens%size())      
      
      tokens = parser%getTokens('a %a')
      @assertEqual(2, tokens%size())      
      
      tokens = parser%getTokens('a%a')
      @assertEqual(2, tokens%size())      

      tokens = parser%getTokens('- %i1.1%i1.1')
      @assertEqual(3, tokens%size())      

   end subroutine test_countTokens

   ! Test that getTokens returns the expected vector of tokens. 
   ! Note that getTokens internally calls startOfNextToken.
   @test
   subroutine test_getTokens()
      use FTL_String_mod
      type(FormatParser) :: parser
      type(StringVec) :: tokens
      integer :: i

      tokens = parser%getTokens('a')
      @assertTrue(String('a') == tokens%at(1))

      tokens = parser%getTokens(' a')
      @assertTrue(String(' a') == tokens%at(1))

      tokens = parser%getTokens('a ')
      @assertTrue(String('a ') == tokens%at(1))      
      
      tokens = parser%getTokens('hello %i2.1')
      @assertTrue(String('hello ') == tokens%at(1))
      @assertTrue(String('%i2.1') == tokens%at(2))

      tokens = parser%getTokens('hello %i2.1 other words %a ')
      @assertTrue(String('hello ') == tokens%at(1))
      @assertTrue(String('%i2.1') == tokens%at(2))
      @assertTrue(String(' other words ') == tokens%at(3))
      @assertTrue(String('%a') == tokens%at(4))
      @assertTrue(String('') == tokens%at(5))

      tokens = parser%getTokens('hello %(i2.1)other words %a ')
      @assertTrue(String('hello ') == tokens%at(1))
      @assertTrue(String('%(i2.1)') == tokens%at(2))
      @assertTrue(String('other words ') == tokens%at(3))
      @assertTrue(String('%a') == tokens%at(4))
      @assertTrue(String('') == tokens%at(5))

      tokens = parser%getTokens('- %i1.1 %i2.1 %i3.1 %i4.1 %i5.1 %i6.1 %7.1')
      @assertTrue(String('-') == tokens%at(1))
      @assertEqual(14, tokens%size())
      @assertTrue(String('%7.1') == tokens%at(14))

      tokens = parser%getTokens('- %i1.1 %i2.1 %i3.1 %i4.1 %i5.1 %i6.1 %7.1 %8.1 %9.1')
      @assertTrue(String('-') == tokens%at(1))
      @assertEqual(18, tokens%size())
      @assertTrue(String('%9.1') == tokens%at(18))
   end subroutine test_getTokens


   ! makeString is a layer on top of 'format'. The following tests check that
   ! makeString returns a string constructed from a format specification.
   @test
   subroutine test_makeString()
      type(FormatParser) :: parser

      ! Regular text format specifier returns the same text
      @assertEqual('hello', parser%makeString('hello'))
      @assertEqual('goodbye', parser%makeString('goodbye'))
      ! Optional argument without a format specification does nothing
      @assertEqual('hello', parser%makeString('hello', 1))
      ! Optional argument with a format specification
      @assertEqual('- 1', parser%makeString('- %i1.1', 1))

      @assertEqual('- 12', parser%makeString('- %i1.1%i1.1', 1, 2))
      @assertEqual('- 1 02 003', parser%makeString('- %i1.1 %i2.2 %i3.3', 1, 2, 3))

      @assertEqual('- (1)', parser%makeString('- (%(i1.1))', 1))
      @assertEqual('value:: 1', parser%makeString('value:: %(i1.1)', 1))


   end subroutine test_makeString

   
   @test
   subroutine test_makeStringManyArgs()
      type(FormatParser) :: parser
      integer :: i=1, j=2, k=3
      integer(kind=8) :: time=1234567890
      real :: u=10.0, v=5.0, T=273.0
      real(kind=8) :: E=0.0, p=3.1415927
      logical :: land=.true.
      character(len=:), allocatable :: str
      character(len=:), allocatable :: fmt

      fmt = '- %i1.1 %i2.2 %i3.3 %i1.1 %i2.2'
      @assertEqual('- 1 02 003 1 02', parser%makeString(fmt, i, j, k, i, j))
      
      fmt = '- %i1.1 %i2.2 %i3.3 %f5.2'
      @assertEqual('- 1 02 003 10.00', parser%makeString(fmt, i, j, k, u))
      
      fmt = '- %i1.1 %i2.2 %f5.2 %f4.2 %f5.1'
      @assertEqual('- 1 02 10.00 5.00 273.0', parser%makeString(fmt, i, j, u, v, T))
      
      fmt = '- %i1.1 %i2.2 %i1.1 %i2.2 %i3.3 %i1.1 %i2.2 %i3.3 %i3.3'
      str = parser%makeString(fmt ,i,j,i,j,k,i,j,k,k)
      
      @assertEqual('- 1 02 1 02 003 1 02 003 003', str)
      @assertEqual('- 0.0 3.1415927', parser%makeString('- %f3.1 %f9.7', E, p))
      @assertEqual('- 1234567890', parser%makeString('- %i10.1', time))
      @assertEqual('- T', parser%makeString('- %l1', land))

   end subroutine test_makeStringManyArgs

   @test
   subroutine test_makeString_detectMissingArg()
      type(FormatParser) :: parser

      character(len=:), allocatable :: str

      str = parser%makeString('hello %i1')
      @assertExceptionRaised('Not enough values for format string in FormatParser.')

   end subroutine test_makeString_detectMissingArg


   @test
   subroutine test_makeString_detectMissingArgB()
      type(FormatParser) :: parser

      character(len=:), allocatable :: str

      str = parser%makeString('hello %i1 %i1', 1)
      @assertExceptionRaised('Not enough values for format string in FormatParser.')

   end subroutine test_makeString_detectMissingArgB


   ! gfortran 4.9.2 cannot handle unlimited polymorphic for
   ! deferred length strings, so we extend the Logger interface to 
   ! format String objects which wrap deferred length strings
   @test
   subroutine test_makeStringWrapString()
      type(FormatParser) :: parser
      
      @assertEqual('hello there', parser%makeString('hello %a', String('there')))

   end subroutine test_makeStringWrapString


   @test(ifndef=__GFORTRAN__)
   subroutine test_makeStringString()
      type(FormatParser) :: parser
      
      @assertEqual('hello there', parser%makeString('hello %a', 'there'))

   end subroutine test_makeStringString


   @test
   subroutine test_makeStringExtra()
   use ASTG_CIStringUnlimitedMap_mod, only: CIStringUnlimitedMap => Map
      type(FormatParser) :: parser
      type (CIStringUnlimitedMap) :: extra
      
      call extra%insert('Carlos', 1)
      call extra%insert('Tom', 2)
      
      @assertEqual('hello', parser%makeString('hello', extra=extra))
      @assertEqual('Carlos is 1', parser%makeString('Carlos is %(Carlos::i1)', extra=extra))
      @assertEqual('Tom is 02', parser%makeString('Tom is %(Tom::i2.2)', extra=extra))
      @assertEqual('-1-2 002', parser%makeString('-%(Carlos::i1)-%i1 %(Tom::i3.3)', 2, extra=extra))

   end subroutine test_makeStringExtra


   @test
   subroutine test_newLine()
      type(FormatParser) :: parser
      character(len=:), allocatable :: str
      
      @assertEqual('hello' // new_line('a'), parser%makeString('hello\n'))
      @assertEqual('hello\n', parser%makeString('hello\\n'))
      @assertEqual('hello' // new_line('a') // 'goodbye', parser%makeString('hello\ngoodbye'))

      @assertEqual('A ' // new_line('a') // ' B \' // new_line('a'), parser%makeString('A \n B \\\n'))

      str = parser%makeString('hello\')
      @assertExceptionRaised("FormatParser:: Cannot terminate format with bare escape '\' character.")

   end subroutine test_newLine

   @test
   subroutine test_listDirected()
      type(FormatParser) :: parser
      character(len=:), allocatable :: str
      integer :: i
      real :: x
      logical :: flag

      str = parser%makeString('%*', 1)
      read(str,*) i
      @assertEqual(1, i)

      str = parser%makeString('%*', 1.)
      read(str,*) x
      @assertEqual(1., x)

      str = parser%makeString('%*', .true.)
      read(str,*) flag
      @assertEquivalent(.true., flag)

   end subroutine test_listDirected


!   @test
   subroutine test_Array()
      type (FormatParser) :: parser
      
      @assertEqual('1', parser%makeString('%i1.1', arr1D_1=[1]))
      @assertEqual('1,2', parser%makeString('%(i1.1,",",i1.1)', arr1D_1=[1,2]))
      @assertEqual('hello 0 1,2,', parser%makeString('hello %i1.1 %(2(i1.1,","))', 0, arr1D_1=[1,2]))

      @assertEqual('1. 2. 3. ', parser%makeString('%(3(f2.0,x))', arr1D_1=[1.,2.,3.]))

! TODO: Need to FIX      
      @assertEqual('1. 2. 3.', parser%makeString('%(3(f2.0,:,x))', arr1D_1=[1.,2.,3.]))

   end subroutine test_array

end module Test_FormatParser_mod
