module Test_ParserContexts_mod
   use pFUnit_mod
   use PFL_FormatToken_mod
   use PFL_FormatParser_mod
   use iso_c_binding, only: C_NULL_CHAR
   implicit none

   @testParameter(constructor=newTestParameter)
   type, extends(AbstractTestParameter) :: TestParam

      ! in
      procedure (ContextInterface), nopass, pointer :: in_context
      character(len=:), allocatable :: inBuffer
      character(len=1) :: nextChar

      ! expected
      character(len=:), allocatable :: outBuffer
      procedure (ContextInterface), nopass, pointer :: outContext
      logical :: startNewToken
      type (FormatToken) :: token
      character(len=:), allocatable :: errorMessage

      procedure (ContextInterface), nopass, pointer :: prevContext
   contains
      procedure :: toString
   end type TestParam
      

   @TestCase(constructor=newTestCase, testParameters={getParameters()})
   type, extends(ParameterizedTestCase) :: ContextsTestCase
      type (FormatParser) :: parser
      type (TestParam) :: param
   contains
      procedure :: setUp
      procedure :: tearDown
   end type ContextsTestCase

contains

   
   function getParameters() result(params)
      type (TestParam), allocatable :: params(:)

      type struct
         procedure (ContextInterface), nopass, pointer :: in_context
         character(len=:), allocatable :: inBuffer
         character(len=1) :: char
         character(len=:), allocatable :: outBuffer
         logical :: startNewToken
         procedure (ContextInterface), nopass, pointer :: outContext
      end type struct

      ! workaround for CPP "eating" backspaces
      character(len=*), parameter :: CPP_SAFE_ESCAPE = '\\'
      character(len=1), parameter :: ESCAPE = CPP_SAFE_ESCAPE(1:1)

      type (TestParam), allocatable :: textCases


      ! Here we have a long list of cases that specify input state
      ! (context, buffer) and expected output state (context, buffer,
      ! new token) for a given input character.  E.g. if the parser
      ! has the textContext then a regular character of text should
      ! not change the context and should just append the character to
      ! the buffer.

      ! Generally, as problems with the parsing are found, additional
      ! cases should be added below.

      procedure (ContextInterface), pointer :: TXC
      procedure (ContextInterface), pointer :: SQC
      procedure (ContextInterface), pointer :: DQC
      procedure (ContextInterface), pointer :: PSC
      procedure (ContextInterface), pointer :: KYC
      procedure (ContextInterface), pointer :: ESC

      TXC => textContext
      SQC => singleQuoteContext
      DQC => doubleQuoteContext
      PSC => positionContext
      KYC => keywordContext
      ESC => escapeContext

      params = [ &
           
           &   p( TXC,  '',    'a',    TXC, 'a'  )                            &
           & , p( TXC, 'a' ,   'b',    TXC, 'ab' )                            &

           ! TXC transitions
           ! TXC -> SQC
           & , p( TXC, 'a',    "'",    SQC, "a'" )                            &
           ! TXC -> DQC
           & , p( TXC, 'a',    '"',    DQC, 'a"' )                            &
           ! TXC -> PSC
           & , p( TXC, 'b',    '%',    PSC, '',      FormatToken(TEXT, 'b') ) &

           ! TXC -> ESC
           & , p( TXC, 'b',    ESCAPE, ESC, 'b'  )                            &
           & , p( ESC, 'b',    'n',    TXC, 'b' // new_line('a') ) &
           
           ! quote contexts
           & , p( SQC, "a'b",  "x",    SQC, "a'bx")                           &
           & , p( SQC, "a'b",  "'",    TXC, "a'b'", prevContext=TXC)          &
           & , p( SQC, "a'b",  '"',    SQC, "a'b" // '"' )                    &
           & , p( SQC, "i3'b",  "'",   PSC, "i3'b'", prevContext=PSC )        &

           & , p( DQC, 'a"b',  'x',    DQC, 'a"bx')                           &
           & , p( DQC, 'a"b',  '"',    TXC, 'a"b"', prevContext=TXC)                           &
           & , p( DQC, 'a"b',  "'",    DQC, 'a"b' // "'" )                    &
           & , p( DQC, 'i3"b',  '"',   PSC, 'i3"b"', prevContext=PSC )        &

           & , p( SQC, "word)i3'b",  "'",   KYC, "word)i3'b'", prevContext=KYC )        &
           & , p( DQC, 'word)i3"b',  '"',   KYC, 'word)i3"b"', prevContext=KYC )        &
           
           ! position context
           & , p( PSC,  'i',  '3',   PSC, 'i3')                               &
           & , p( PSC, 'i3',  ' ',    TXC, ' ',      FormatToken(POSITION, 'i3') ) &
           & , p( PSC, 'i3', '~',  TXC, '',      FormatToken(POSITION, 'i3') ) &
           ! looks like position but turns out to be a keyword
           & , p( PSC,   '',     '(',    KYC, '')                            & 
           & , p( PSC,   'i3',     "'",    SQC, "i3'")                       & 
           & , p( PSC,   'i3',     '"',    DQC, 'i3"')                       & 
           & , p( PSC,   '',     '%',    TXC, '%')                           & 

           ! keyword context
           & , p( KYC,        '',  'v', KYC, 'v')                                 &
           & , p( KYC,  'var',  ')', KYC, 'var)')                                &
           & , p( KYC,  'word)a',  ' ', TXC, ' ', FormatToken(KEYWORD, 'word)a')) &
           & , p( KYC,  'word)a',  C_NULL_CHAR, TXC, '', FormatToken(KEYWORD, 'word)a')) &
           & , p( KYC,  'word)i3',  '~', TXC, '', FormatToken(KEYWORD, 'word)i3')) &
           & , p( KYC,   'abc)',  C_NULL_CHAR, TXC, '', FormatToken(KEYWORD, 'abc)*')) &

           ! Various checks on illegal formats
           ! (1) illegal terminations
           & , p( ESC, '',  '.',   illegalContext, '', &
           &   errorMessage='FormatParser::escapeContext() - no such escape sequence: \.') &
           & , p( SQC, "a'b",  C_NULL_CHAR,    illegalContext, "a'b", &
           &   errorMessage='FormatParser::singleQuoteContext() - unclosed single quote') &
           & , p( DQC, 'a"b',  C_NULL_CHAR,    illegalContext, 'a"b', &
           &   errorMessage='FormatParser::doubleQuoteContext() - unclosed double quote') &

           & , p( PSC,   '',  C_NULL_CHAR,     illegalContext, '', &
           &   errorMessage='FormatParser::positionContext() - empty edit descriptor') &
           & , p( KYC,   'abc',  C_NULL_CHAR,     illegalContext, 'abc', &
           &   errorMessage='FormatParser::keywordContext() - missing ")"')  &

           ! Cannot switch to keyword once there is a format descriptor
           & , p( PSC, 'i3',     '(',    PSC, 'i3(') &
           & , p( KYC,        '',  ')', illegalContext, ')',  &
           &  errorMessage='FormatParser::keywordContext() - missing keyword?') &

           & ]

   contains

      
      function p(in_context, inBuffer, char, outContext, outBuffer, token, errorMessage, prevContext)
         type (TestParam) :: p
         
         procedure (ContextInterface) :: in_context
         character(len=*), intent(in) :: inBuffer
         character(len=1), intent(in) :: char
         procedure (ContextInterface) :: outContext
         character(len=*) :: outBuffer
         type (FormatToken), optional, intent(in) :: token
         character(len=*), optional, intent(in) :: errorMessage
         procedure (ContextInterface), optional :: prevContext

         p%in_context => in_context
         p%inBuffer = inBuffer
         p%nextChar = char
         p%outBuffer = outBuffer
         p%outContext => outContext

         if (present(token)) then
            p%startNewToken = .true.
            p%token = token
         else
            p%startNewToken = .false.
         end if

         if (present(errormessage)) then
            p%errorMessage = errorMessage
         end if

         if (present(prevContext)) then
            p%prevContext => prevContext
         end if

      end function p


   end function getParameters


   function toString(this) result(str)
      character(len=:), allocatable :: str
      class (TestParam), intent(in) :: this
      
      character(len=:), allocatable :: message
      procedure(ContextInterface), pointer :: p1, p2, p3, p4, p5, p

      message = 'in context='
      p1 => textContext
      p2 => singleQuoteContext
      p3 => doubleQuoteContext
      p4 => positionContext
      p5 => keywordContext

      p => this%in_context
      if (associated(p, p1)) then
         message = message // 'textContext' // new_line('a')
      elseif (associated(p, p2)) then
            message = message // 'singleQuoteContext' // new_line('a')
      elseif (associated(p, p3)) then
            message = message // 'doubleQuoteContext' // new_line('a')
      elseif (associated(p, p4)) then
         message = message // 'positionContext' // new_line('a')
      elseif (associated(p, p5)) then
         message = message // 'keywordContext' // new_line('a')
      end if

      message = message // 'inBuffer=<' // this%inBuffer // '>'
      message = message // '; char=<' // this%nextChar // '>'

      str = message

   end function toString


   function newTestCase(param) result(tstCase)
      type (ContextsTestCase) :: tstCase
      type (TestParam) :: param

      tstCase%param = param

   end function newTestCase


   subroutine setUp(this)
      class (ContextsTestCase), intent(inout) :: this

      if (associated(this%param%prevContext)) then
         call this%parser%set_context(this%param%prevContext)
         call this%parser%push_context()
      end if
      call this%parser%set_context(this%param%in_context)

      call this%parser%set_buffer(this%param%inBuffer)

      call this%param%in_context(this%parser, this%param%nextChar)
      if (allocated(this%param%errorMessage)) then
         @assertExceptionRaised(this%param%errorMessage)
      end if


   end subroutine setUp

   subroutine tearDown(this)
      class (ContextsTestCase), intent(inout) :: this
   end subroutine tearDown


!----------------
! Check that the output state of buffer is correct.
!----------------
@test
   subroutine test_outBuffer(this)
      class (ContextsTestCase), intent(inout) :: this

      character(len=:), pointer :: buffer

      call this%parser%get_buffer(buffer)
      @assertEqual(this%param%outBuffer, buffer, whiteSpace=KEEP_ALL)

   end subroutine test_outBuffer


!----------------
! Check that the output state of context is correct.
!----------------
@test
   subroutine test_outContext(this)
      class (ContextsTestCase), intent(inout) :: this

      procedure (ContextInterface), pointer :: procPtr
      procedure (ContextInterface), pointer :: expectedPtr

      call this%parser%get_context(procPtr)
      expectedPtr => this%param%outContext
      @assertTrue(associated(procPtr, expectedPtr), 'incorrect state transition')

   end subroutine test_outContext


!---------------------------------------------------------
! Check that a new token is created only when appropriate.
!---------------------------------------------------------
@test
   subroutine test_startNewToken(this)
      class (ContextsTestCase), intent(inout) :: this

      procedure (ContextInterface), pointer :: procPtr
      type (FormatToken), pointer :: token

      if (this%param%startNewToken) then
         @assertEqual(1, this%parser%size())
         token => this%parser%at(1)
         @assertEqual(this%param%token%type, token%type, 'incorrect token type')

         select case (this%param%token%type)
         case (TEXT)
            @assertEqual(this%param%token%text, token%text)
         case (POSITION)
            @assertEqual(this%param%token%edit_descriptor, token%edit_descriptor)
         case (KEYWORD)
            @assertEqual(this%param%token%text, token%text)
            @assertEqual(this%param%token%text, token%text)
         end select

      else
         @assertEqual(0, this%parser%size())
      end if

   end subroutine test_startNewToken


end module Test_ParserContexts_mod
