module Test_MpiLock_mod
   use pfunit_mod
   use astg_MpiLock_mod
   use mpi
   use MockMpi_mod
   implicit none

contains

   ! Testing locks is a bit subtle because the effects are indirect.
   ! We use the mock layer to simulate the conditions in which one
   ! process has already aquired (but not released) the lock.
   ! We need acquire() on 'this' process to nonetheless return
   ! so that we can probe the status.
   
   @test
   subroutine test_acquire_wait()
      type (MpiLock) :: lock
      real, parameter :: DT = 0.01 !seconds
      integer, parameter :: LOCK_TAG = 10

      integer :: comm, ierr
      integer :: buffer = 1
      integer :: status(MPI_STATUS_SIZE)
      logical :: flag
      
      ! configure the mock layer

      call set_mpi_rank(1)
      call set_mpi_size(2)

      call set_MPI_Get([.true.])
      lock = MpiLock(comm)

      call lock%acquire()
      call verify()
      
   end subroutine test_acquire_wait

end module Test_MpiLock_mod
